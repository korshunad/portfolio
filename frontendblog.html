<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Frontend for Beginners ● Ana Makarochkina</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"/>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />

    <link rel="stylesheet"  type="text/css" href="main.css"/>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:200,400,600&display=swap" rel="stylesheet">
    <link href="prism.css" rel="stylesheet" />
    <script src="scrollMenu.js"></script>
  </head>
  <body class="mw9 center">
    <nav class="flex flex-row flex-nowrap-l flex-wrap items-center justify-between ph5-l ph4-m ph3 pv3">
      <div class="flex flex-row justify-start w-100-ns w-50 mw5-l items-center w-auto-m">
        <a href="index.html">
          <img src="images/logo.svg" class="mw4 w-100 h-auto" alt="Korshunad logo of Ana Makarochkina"/>
        </a>
      </div>
      <ul class="dn-ns flex flex-row-l flex-column justify-between items-stretch-l items-start mw5-l w-100-ns w-50 mw3 pl4-l pl0">
        <li>
          <a href="hire-me.html" title="Ana contact for hiring" class="link"/>
            Hire Me
          </a>
        </li>
        <li>
          <a href="about.html" title="About Ana Makarochkina" class="link"/>
            About
          </a>
        </li>
      </ul>
      <div class="flex flex-column justify-center items-center pt0-ns pt4  w-100">
        <span class='b f4'>Ana Makarochkina</span>
        <span class="fw3 f4">Frontend Developer</span>
      </div>
      <ul class="flex-ns dn flex-row-l flex-column justify-between items-stretch-l items-start mw5-l w-100 mw3-m pl4-l pl0">
        <li>
          <a href="hire-me.html" title="Ana contact for hiring" class="link"/>
            Hire Me
          </a>
        </li>
        <li>
          <a href="about.html" title="About Ana Makarochkina" class="link"/>
            About
          </a>
        </li>
      </ul>
    </nav>
    <main class="ph5-l ph4-m ph3 pv3">
      <section class="flex flex-row-l flex-column-reverse items-end ">
        <div class="w-50-l w-100 pr3-l">
          <h1 class="f1-ns f2 mb0">Frontend for Beginners</h1>
          <h3 class="f3-ns f4 fw4 lh-copy">Building a React.js powered blog with automated code quality control</h3>
          <button class="ttu tracked f3 br2" onclick="window.open('https://highstart.dev')">Visit site</button>
        </div>
        <img src="images/frontend_blog.png" class="shadow w-50-l w-100 h-auto"/>
      </section>
      <div class="relative flex flex-row-l flex-column overflow-visible">
        <section class="sticky-l relative pv5-l pt4 h-100-l pr5-l">
          <ul class="pl0 flex flex-column items-start">
            <li onclick="scrollSectionIntoView(this);">
              <a class="link active" data-href="#intro">Introduction</a></li>
            <li onclick="scrollSectionIntoView(this);">
              <a class="link flex" data-href="#preparation">Blog Preparation and Development</a></li>
            <li onclick="scrollSectionIntoView(this);">
              <a class="link flex" data-href="#code-quality">Code Quality</a></li>
            <li onclick="scrollSectionIntoView(this);">
              <a class="link flex" data-href="#testing">Automated Testing</a></li>
            <li onclick="scrollSectionIntoView(this);">
              <a class="link" data-href="#collaboration">Collaboration</a></li>
            <li onclick="scrollSectionIntoView(this);">
              <a class="link flex" data-href="#result">Overall result</a></li>
          </ul>
        </section>
        <div>
          <section class="pt5-l pt4 content" id="intro">
            <h2 class="f2-ns f3">Context</h2>
            <p>Frontend for Beginners is a blog about front-end development, tailored to beginners. It is a joint effort of the team of 4 people and was in the active content and web development phase in May - June 2019. My roles in the project were the developer and articles writer.</p>
            <h2 class="f2-ns f3">Overview</h2>

            <p>The goal was to build a blog about web development where different authors can add their articles in code and overall collaborate on enhancing the blog’s functionality.</p>
            <p> It was achieved by using current technologies:<br/>
            <span class="text-highlight">React.js, Gatsby.js, Mocha testing engine</span><br/>
            and collaborative tools:<br/>
            <span class="text-highlight">Github, CircleCI</span>.</p>
          </section>
          <section class="pt5-l pt4 content" id="preparation">
            <h2 class="f2-ns f3 mt0">Blog preparation and development</h2>
            <h3 class="f3-ns f4">Problem</h3>
            <p>When planning the blog, I wanted to build it with modern technologies, which are also easy to pick up by other developers who may be collaborating with me on the project. Also, I didn’t want to lock down into solutions that add too much complexity from the very beginning.</p>
            <p>However, I also looked for basic blog functionality to be present as well, such as templates for the articles and automatic web pages generation for new articles.</p>
            <h3 class="f3-ns f4">Solution</h3>
            <p>The solution for the modern and easy to start collaborating blog was the Gatsby js framework. It leverages React.js and Webpack for frontend development, GraphQL query language for data management, and an extensive system of plugins.</p>
            <p>To set up the blog, I performed the following steps:</p>
            <ol>
              <li>
                Generate a basic Gatsby.js project;
              </li>
              <li>
                Add main layout components: header, footer, column structure for the articles, code the about page;
              </li>
              <li>
                <p>
                Setup the templates for the blog post pages, set up an automatic generation of the new blog pages and new tags pages
                </p>
                <div class="gist">
                  <script src="https://gist.github.com/korshunad/3349a73b240a681bfba42a5561304b8d.js"></script>
                </div>
              </li>
              <li>
                Group the articles into main website categories - articles and tutorials on the home page and respective articles and tutorials pages with  Array.map() method;
              </li>
              <li>
                <p>
                Setup the template for the social sharing meta tags automatically generated for each blog page;
                </p>
                <div class="gist">
                  <script src="https://gist.github.com/korshunad/e0777036a089b6c1037b02b93d4e842b.js"></script>
                </div>
              </li>
              <li>
                Setup automatic deployment to Netlify;
                <br/>
                <img src="images/circleCIdeploys.png" class="mw6 w-100 h-auto"/>
                <br/>
                <img src="images/production_published.png" class=" w-100 h-auto"/>
              </li>
            </ol>
          </section>
          <section class="pt5-l pt4 content" id="code-quality">
            <h2 class="f2-ns f3">Code Quality</h2>
            <h3 class="f3-ns f4">Problem 1: Linting code</h3>
            <p>
            Code quality revolves mainly about code readability and styling conventions used in the repository. In the case of this project, maintaining code quality is important both for myself and any other collaborators.
            </p>
            <p>
            Commonly it is achieved by setting up linters, that highlight all the syntax errors and styling inconsistencies.
            </p>
            <h3 class="f3-ns f4">Solution 1: Linting code</h3>
            <p>
            One of the best linters for Javascript is JSLint. Gatsby already uses JSLint, but by default, it lints everything during the development process and does not restrict pushing poorly formatted code.
            </p>
            <p>
            Running JSLint commands in the project as is checks the whole project’s codebase and may also automatically fix minor errors.
            </p>
            <p>
            To check only the code that was changed and staged for the commit:
            </p>
            <ul class="lh-copy pl0">
              <li class="flex flex-column items-start mb4">
                I added the husky package that allows using git hooks, which may prevent the commits. I tested it to show the commit message when a commit is made and then configured to run lint-staged:
                <pre><code class="language-json">
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },</code></pre>
              </li>
              <li class="flex flex-column items-start mb4">
                Then I added the lint-staged package and set it to lint only the committed code:

                <pre><code class="language-json">
  "lint-staged": {
    "*.js": [
      "eslint --fix",
      "git add"
    ]
  },</code></pre>
              </li>
            </ul>
            <h3 class="f3-ns f4">Problem 2: Linting commits</h3>
            <p>
            When committing the added or changed code, developers may use different conventions or no conventions at all. This may result in huge commits or small commits, which, most importantly, may be hard to debug by the author or teammates.
            </p>
            <p> Therefore it is one of the best practices to structure the commits in the form of “<type>[optional scope]: <description>”, where type is a category of the code change, and description brings more details to it.
            </p>
            <h3 class="f3-ns f4">Solution 2: Linting commits</h3>
            <p>
            Forcing developers to remember the styling convention may make life just harder. Therefore I added “commit-lint” that checks the commit message to conform to the “<type>[optional scope]: <description>” format and reminds of the existing types if the type is off.
            </p>
            <p>
            For that, I added another package “commit-lint” and configured the husky setup to check the text of the commit, additionally to checking the files being committed.
            </p>
            <h4 class=" lh-copy">
              Commit-lint setup in the package.json:
            </h4>
            <pre><code class="language-json">
  "commitlint": {
    "rules": {
      "type-empty": [ // to prevent adding commits with no category, no type
        2,
        "never"
      ],
      "header-min-length": [
        2,
        "always",
        3
      ],
      "type-enum": [ // to specify types that can be used
        2,
        "always",
        [
          "feat",
          "fix",
          "docs",
          "style",
          "refactor",
          "test",
          "revert",
          "setup"
        ]
      ]
    }
  },</code></pre>
            <h4 class=" lh-copy">
              New husky setup:
            </h4>
            <pre><code class="language-json">
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
      "pre-commit": "lint-staged"
    }
  },</code></pre>
            <h4 class=" lh-copy">
              After all the setup, the commit checks looks like the following:
            </h4>
            <ul>
              <li>
                <p>
                Commit staged files with a message:
                </p>
                <pre class="language-bash"><code>
$ git commit -m 'test: check if lint-staged and commit-lint are working'
husky > pre-commit (node v10.15.3)
                </code></pre>
              </li>
              <li>
                <p>
                Linter runs and checks selected files:
                </p>
                <pre class="language-bash"><code>$ git commit -m 'test: check if lint-staged and commit-lint are working'
husky > pre-commit (node v10.15.3)
  ↓ Stashing changes... [skipped]
    → No partially saved files found...
  ❯ Running linters...
    ❯ Running tasks for *.js
      ∷ eslint --fix
        git add</code></pre>
              </li>
              <li>
                <p>
                Commit-lint checks if the commit message is formatted properly:
                </p>
                <pre class="language-bash"><code>$ git commit -m 'test: check if lint-staged and commit-lint are working'
husky > pre-commit (node v10.15.3)
  ↓ Stashing changes... [skipped]
    → No partially saved files found...
  ✓ Running linters...
husky > commit-msg (node v10.15.3)

⧗  input: test: check if lint-staged and commit-lint are working
✓  found 0 problems, 0 warnings
   (Need help? -> https://github.com/conventional-changelog/commitlint#what-is-commitlint)

[master 6e36fcf] test: check if lint-staged and commit-lint are working
 1 file changed, 7 insertions(+)
 create mode 100644 app.js
                </code></pre>
              </li>
              <li>
                <p>
                If formatting is off, commit-lint raises a warning:
                </p>
                <pre class="language-bash"><code>$ git commit -m 'wrongtype: test wrong commit format'
husky > pre-commit (node v10.15.3)
No staged files match any of provided globs.
husky > commit-msg (node v10.15.3)

⧗  input: wrongtype: test wrong commit format
✖  type must be one of [feat, fix, docs, style, refactor, test, revert, setup] [type-enum]
✖  found 1 problems, 0 warnings
   (Need help? -> https://github.com/conventional-changelog/commitlint#what-is-commitlint)

husky > commit-msg hook failed (add --no-verify to bypass)
                </code></pre>
              </li>
              </uL>
          </section>
          <section class="pt5-l pt4 content" id="testing">
            <h2 class="f2-ns f3">Automated Testing</h2>
            <h3 class="f3-ns f4">Problem</h3>
            <p>
            Programming collaboratively is based on trust. Certainly, you are reviewing the teammate’s code in the pull request, and optionally even pull the branch they worked in to test changes locally. However, it is great to have the tests run automatically to see new changes do not break that main functionality.
            </p>
            <h3 class="f3-ns f4">Solution</h3>
            <p>
            The result I was approaching was the following: when a pull request is made to the master branch, the automated tests run to see whether existing pages are displayed correctly. This is done with 3 main components:
            </p>
            <ul>
              <li>
                CircleCi project setup that runs tests when a pull request is made to the master branch, and displays pass or fail flag on the pull request page;
              </li>
              <li>
                Mocha testing engine, that is used for writing the tests, ensuring the web pages contain correct content when loaded;
              </li>
              <li>
                Puppeteer, the Headless Chrome Node API that opens web pages in Chrome and gets their content
              </li>
            </ul>
            <p>
            The steps to set up were the following:
            <ol class="lh-copy">
              <li class="mb3">
                Setup the CircleCI project in the CircleCI project with the frontendForBeginners repository;
              </li>
              <li class="mb3">
                Add the .circleci/config.yml configuration file and validate it with circleCI CLI. Validation was necessary as I ran into syntax errors when copying the config code into VIM code editor and the .yml whitespace syntax is pretty strict;
                <br>
                config.yml file:
                <pre class="language-yml"><code># Javascript Node CircleCI 2.0 configuration file
#
# Check https://circleci.com/docs/2.0/language-javascript/ for more details
#
version: 2
jobs:
  build:
    docker:
      # specify the version you desire here
      - image: circleci/node:latest-browsers

        # Specify service dependencies here if necessary
        # CircleCI maintains a library of pre-built images
        # documented at https://circleci.com/docs/2.0/circleci-images/
        # - image: circleci/mongo:3.4.4

    working_directory: ~/repo

    steps:
        - checkout

          # Download and cache dependencies
        - restore_cache:
            keys:
              - v1-dependencies-{{ checksum "package.json" }}
                # fallback to using the latest cache if no exact match is found
              - v1-dependencies-

        - run: npm install

        - save_cache:
            paths:
              - node_modules
            key: v1-dependencies-{{ checksum "package.json" }}</code></pre>
              </li>
              <li class="mb3">
                Serve the built version of the blog (static website, build folder) with Express.js.
                server-test.js:
                <pre class="language-js"><code>const express = require('express');
const app = express();

const ejs = require('ejs');

let server;

app.use(express.static('public'));
server = app.listen(3000, () => console.log('Example app listening on port 3000!'));
                </code></pre>
              </li>
              <li class="mb3">
                Write Mocha tests, that run the website on a local server and open the headless chrome instance. Then get specific pages with Puppeteer and check if they contain the title element of the page.
                <pre class="language-js"><code>describe('puppeteer checks the blog', () => {
  before(async () => {
    app.use(express.static('public'));
    server = app.listen(3000, () => console.log('Example app listening on port 3000!'));
    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
  });
  it('open home page successfully', async () => {
    const page = await browser.newPage();
    await page.goto('http://127.0.0.1:3000/', {waitUntil: 'networkidle2'});
    const bodyHTML = await page.evaluate(() => document.body.innerHTML);

    const regex = /&lt;span class="code-right"&gt;(.*?)\&lt;/span&gt;/g;
    let found = bodyHTML.match(regex);
    expect(found[0]).to.equal("&lt;span class=\"code-right\"&gt;Hello World!&lt;/span&gt;");
  });
                </code></pre>
                <p>
                Close the Chrome browser and server when the tests end
                </p>
                <pre class="language-js"><code>after(async () => {
  await browser.close();
  server.close();
});</code></pre>
              </li>
              <li class="mb3">
                As the tests rely on the built version of the website, add the build and then test command to the .circleci/config.yml file
                <pre class="language-yml"><code>        - run: npm install

        # add build step to be able to run tests
        - run: npm run build

        - save_cache:
            paths:
              - node_modules
            key: v1-dependencies-{{ checksum "package.json" }}

        # run tests!
        - run: npm run test</code></pre>
              </li>
            </ol>
            <p>
            As a result, the pull request can be merged into master after the code review and after the CircleCI tests have passed
            </p>
            <img src="images/circleCI_pass.png"/>
            <p>
            And this is how the tests are passing.
            </p>
            <iframe width="100%" height="315" src="https://www.youtube.com/embed/p8AgRRgx3ok?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          </section>
          <section class="pt5-l pt4 content" id="collaboration">
            <h2 class="f2-ns f3">Collaboration</h2>
            <h3 class="f3-ns f4">Problem</h3>
            <p>It may be hard to communicate the project structure and development process, as well as the code quality assurance measure.</p>
            <h3 class="f3-ns f4">Solution</h3>
            <p>Up-to-date documentation in the README.md file, which describes the folder structure and main commands used to run the development server and teste. It was tested and then improved with one of the collaborators.</p>
            <div class="gist" style="max-width: 40em; max-height:40vh;">
              <img src="images/frontendForBeginnersDocs.png"/>
            </div>

          </section>
          <section class="pv5-l pt4 pb5 content" id="result">
            <h2 class="f2-ns f3">Overall result</h2>

            <p>The extensible blog is written with React.js, it leverages rich Gatsby.js plugins ecosystem and documentation. Code linting and automated testing ensure code quality.</p>
            <iframe width="100%" height="600" src="https://www.youtube.com/embed/4oV561ERLOM?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          </section>
        </div>
      </div>
    </main>
    <footer class="flex flex-row-ns flex-column-reverse justify-center items-center pb4">
      <p class="f7">&copy; 2019 Korshunad</p>
      <ul class="flex flex-row mv4-l mv0 flex-wrap justify-between mw5-l pa0 ml4-ns">
        <li>
          <a href="hire-me.html" title="Ana contact for hiring" class="link"/>
            Hire Me
          </a>
        </li>
        <li>
          <a href="index.html" title="About Ana Makarochkina" class="link"/>
            Projects
          </a>
        </li>
      </ul>
      </nav>
    </footer>
    <script src="prism.js"></script>

  </body>
</html>
</body>
</html>
